{"version":3,"sources":["models/client.ts"],"names":[],"mappings":";;AAAA,qCAAmD;AACnD,sCAAwC;AASxC,IAAM,YAAY,GAAW,IAAI,iBAAM,CAAE;IACrC,IAAI,EAAE;QACF,IAAI,EAAE,MAAM;QACZ,MAAM,EAAE,IAAI;QACZ,QAAQ,EAAE,IAAI;KACjB;IACD,EAAE,EAAE;QACA,IAAI,EAAE,MAAM;QACZ,QAAQ,EAAE,IAAI;KACjB;IACD,MAAM,EAAE;QACJ,IAAI,EAAE,MAAM;QACZ,QAAQ,EAAE,IAAI;KACjB;IACD,MAAM,EAAE;QACJ,IAAI,EAAE,MAAM;QACZ,QAAQ,EAAE,IAAI;KACjB;CACJ,CAAC,CAAC;AAEH,uCAAuC;AACvC,YAAY,CAAC,GAAG,CAAC,MAAM,EAAE,UAAS,QAAQ;IACxC,IAAI,MAAM,GAAG,IAAI,CAAC;IAElB,yCAAyC;IACzC,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;QAAC,MAAM,CAAC,QAAQ,EAAE,CAAC;IAEpD,uCAAuC;IACvC,MAAM,CAAC,OAAO,CAAC,CAAC,EAAE,UAAS,GAAG,EAAE,IAAI;QAClC,EAAE,CAAC,CAAC,GAAG,CAAC;YAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;QAE9B,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,UAAS,GAAG,EAAE,IAAI;YACvD,EAAE,CAAC,CAAC,GAAG,CAAC;gBAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;YAC9B,MAAM,CAAC,MAAM,GAAG,IAAI,CAAC;YACrB,QAAQ,EAAE,CAAC;QACb,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC;AAEH,YAAY,CAAC,OAAO,CAAC,YAAY,GAAG,UAAS,MAAM,EAAE,EAAE;IACnD,MAAM,CAAC,OAAO,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE,UAAS,GAAG,EAAE,OAAO;QACrD,EAAE,CAAC,CAAC,GAAG,CAAC;YAAC,MAAM,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC;QACxB,EAAE,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;IACtB,CAAC,CAAC,CAAC;AACP,CAAC,CAAC;AAES,QAAA,MAAM,GAAG,gBAAK,CAAU,QAAQ,EAAE,YAAY,CAAC,CAAC","file":"../../src/models/client.js","sourcesContent":["import { Document, Schema, model } from 'mongoose';\nimport * as bcrypt from 'bcrypt-nodejs';\n\ninterface IClient extends Document {\n    name: string;\n    id: string;\n    sectet: string;\n    userId: string;\n}\n\nconst ClientSchema: Schema = new Schema ({\n    name: {\n        type: String,\n        unique: true,\n        required: true\n    },\n    id: {\n        type: String,\n        required: true\n    },\n    secret: {\n        type: String,\n        required: true\n    },\n    userId: {\n        type: String,\n        required: true\n    }\n});\n\n// Execute before each user.save() call\nClientSchema.pre('save', function(callback) {\n  let client = this;\n\n  // Break out if the secret hasn't changed\n  if (!client.isModified('secret')) return callback();\n\n  // Secret changed so we need to hash it\n  bcrypt.genSalt(5, function(err, salt) {\n    if (err) return callback(err);\n\n    bcrypt.hash(client.secret, salt, null, function(err, hash) {\n      if (err) return callback(err);\n      client.secret = hash;\n      callback();\n    });\n  });\n});\n\nClientSchema.methods.verifySecret = function(secret, cb) {\n    bcrypt.compare(secret, this.secret, function(err, isMatch) {\n        if (err) return cb(err);\n        cb(null, isMatch);\n    });\n};\n\nexport let Client = model<IClient>('Cleint', ClientSchema);"]}